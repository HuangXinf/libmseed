<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>UsersGuide.txt</title><link rel="stylesheet" type="text/css" href="../../styles/main.css" /><script type="text/javascript" src="../../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.0.2 -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');" class="NDPage NDContentPage">

<a name="Users_Guide"></a><a name="Topic2"></a><div class="CTopic TSection LTextFile first">
 <div class="CTitle">Users Guide</div>
 <div class="CBody"><div class="CHeading">Data Records</div><p>A Mini-SEED record is represented in the library using the data structure given below.&nbsp; This structure is used for both unpacking and packing of Mini-SEED records.&nbsp; When unpacking with msr_unpack(3) this structure is populated.&nbsp; When packing with msr_pack(3) this structure is used as a template for the resulting data records and as a source of samples to be packed.</p><p>Blockettes following the fixed section of the header are contained in the blockette chain of BlktLink structures.&nbsp; Shortcut pointers to commonly used blockettes are maintained for types 100, 1000 and 1001.</p><p>Many common header fields which are not easily accessible/usable in the raw header are available directly from the structure.&nbsp; When this structure is used as a packing template, these common header fields are packed into the appropriate place in the fixed section or blockette.&nbsp; As examples, the ASCII stream identifiers (network, station, location and channel) are available as NULL terminated strings, the start time is available as a high precision epoch time (see ms_time(3)) and the sample rate is available as a double precision floating point value.</p><p>The MSRecord data structure:</p><p>typedef struct MSRecord_s { char&nbsp; <b>record;&nbsp; /</b> Mini-SEED record <b>/ int32_t&nbsp; reclen;&nbsp; /</b> Length of Mini-SEED record in bytes */</p><p>/* Pointers to SEED data record structures */ struct fsdh_s&nbsp; <b>fsdh;&nbsp; /</b> Fixed Section of Data Header */ struct BlktLink&nbsp; <b>blkts;&nbsp; /</b> Root of blockette chain */ struct blkt_100_s&nbsp; <b>Blkt100;&nbsp; /</b> Blockette 100, if present */ struct blkt_1000_s <b>Blkt1000;&nbsp; /</b> Blockette 1000, if present */ struct blkt_1001_s <b>Blkt1001;&nbsp; /</b> Blockette 1001, if present */</p><p>/* Common header fields in accessible form <b>/ int32_t&nbsp; sequence_number;&nbsp; /</b> SEED record sequence number <b>/ char&nbsp; dataquality;&nbsp; /</b> Data quality indicator <b>/ char&nbsp; network[11];&nbsp; /</b> Network designation, NULL terminated <b>/ char&nbsp; station[11];&nbsp; /</b> Station designation, NULL terminated <b>/ char&nbsp; location[11];&nbsp; /</b> Location designation, NULL terminated <b>/ char&nbsp; channel[11];&nbsp; /</b> Channel designation, NULL terminated <b>/ hptime_t&nbsp; starttime;&nbsp; /</b> Record start time, corrected (first sample) <b>/ double&nbsp; samprate;&nbsp; /</b> Nominal sample rate (Hz) <b>/ int64_t&nbsp; samplecnt;&nbsp; /</b> Number of samples in record <b>/ int8_t&nbsp; encoding;&nbsp; /</b> Data encoding format <b>/ int8_t&nbsp; byteorder;&nbsp; /</b> Byte order of record */</p><p>/* Data sample fields */ void&nbsp; <b>datasamples;&nbsp; /</b> Data samples, 'numsamples' of type 'sampletype'*/ int64_t&nbsp; numsamples;&nbsp; /* Number of data samples in datasamples <b>/ char&nbsp; sampletype;&nbsp; /</b> Sample type code: a, i, f, d */</p><p>/* Stream oriented state information */ StreamState&nbsp; <b>ststate;&nbsp; /</b> Stream processing state information */ } MSRecord;</p><p>Explanation of fields:</p><p>record: Pointer to the Mini-SEED record which was unpacked into the MSRecord.</p><p>reclen: When unpacking this is the record length in bytes of the record pointed to by the 'record' pointer.&nbsp; When packing this is the length of records to pack.</p><p>fsdh: A pointer to the Fixed Section of the Data Header, all appropriate multi-byte quantities are in host byte order.</p><p>blkts: The root of the blockette chain.&nbsp; The chain is constructed from linked BlktLink structures.&nbsp; All appropriate multi-byte quantities in the blockettes are in host byte order.&nbsp; The msr_addblockette(3) routine can be used to add blockettes to this chain.&nbsp; The BlktLink structure and SEED blockette structures are defined in libmseed.h.</p><div class="CHeading">Blkt100</div><div class="CHeading">Blkt1000</div><div class="CHeading">Blkt1001</div><p>Shortcut pointers to common blockettes in the blockette chain.&nbsp; If a given blockette does not exist in the blockette chain the shortcut pointer will be 0.&nbsp; If more than one of these blockette types exist in the chain this pointer will point to the last one.</p><p>sequence_number: SEED record sequence number, should be between 0 and 999999.</p><p>dataquality: Data record indicator, should be 'D', 'R', 'Q' or 'M'.</p><p>network: station: location: channel: SEED stream identifiers as NULL terminated strings.</p><p>starttime: Record start time, the time of the first sample, as a high precision epoch time (seed ms_time(3)).&nbsp; This time can be converted using the various ms_hptime2&lt;X&gt; functions.</p><p>samprate: The sample rate in samples per second in double precision.&nbsp; During unpacking this value will be set to the sample rate given in the 100 blockette if it is present, otherwise the sample rate derived from the factor and multiplier in the fixed section of the header.&nbsp; In a packing template this value will be used to derive a factor and multiplier for the fixed section of the header and will be written into 100 blockettes if any are in the blockette chain.</p><p>samplecnt: The sample count, i.e. number of data samples in the record.</p><p>encoding: The SEED data sample encoding format.&nbsp; During packing this dictates what format will be used to pack the data samples.&nbsp; Supported packing formats are 0 (DE_ASCII), 1 (DE_INT16), 3 (DE_INT32), 4 (DE_FLOAT32), 5 (DE_FLOAT64), 10 (DE_STEIM1) and 11 (DE_STEIM2).</p><p>byteorder: Byte order of multi-byte quantities in the record.&nbsp; A value of 0 indicates little endian and a value of 1 indicates big endian.&nbsp; During packing this dictates the byte order of the final records.</p><p>datasamples: A pointer to the unpacked data samples.&nbsp; If no data samples were unpacked this will be 0.&nbsp; The 'numsamples' field indicates how many samples are in this array and the 'sampletype' field indicates what type of samples they are.</p><p>numsamples: The number of samples pointed to by the 'datasamples' pointer.</p><p>sampletype: The type of samples pointed to by the 'datasamples' pointer.&nbsp; Supported types are 'a' (ASCII), 'i' (integer), 'f' (float) and 'd' (double).&nbsp; The size of each sample type in bytes is returned by the get_samplesize(3) lookup routine.</p><p>ststate: Pointer to a StreamState struct used internally to track stream oriented state variables.&nbsp; Memory for this only allocated when needed.</p><p>-- Traces --</p><p>In order to manage continuous trace segments the library provides a couple of different mechanisms: Trace Groups and Trace Lists.</p><p>Initially only Trace Groups were implimented and later Trace Lists were added, from a general standpoint they do the same thing.&nbsp; The Trace Lists are more efficient and slightly more complicated in their structure.&nbsp; Either can be used for most tasks, but there are more utilities functions for Trace Groups.</p><p>The TraceGroup functionality is centered around the MSTrace data structure and a MSTraceGroup data structure in which MSTrace structures can be grouped.&nbsp; While a MSTrace structure is normally used to hold trace information and associated data samples it can also be used without data samples as a means to keep trace of data coverage without actual samples.</p><p>Numerous routines are provided for basic management of MSTrace structures, including the creation of new MSTrace structures, adding data from Mini-SEED data structures to MSTrace structures, printing trace information, etc.</p><p>The MSTraceGroup data structure acts as a very simple place to begin a chain of MSTrace structures and keep track of the number of traces.</p><p>The MSTrace and MSTraceGroup data structures:</p><p>typedef struct MSTrace_s { char&nbsp; network[11];&nbsp; /* Network designation, NULL terminated <b>/ char&nbsp; station[11];&nbsp; /</b> Station designation, NULL terminated <b>/ char&nbsp; location[11];&nbsp; /</b> Location designation, NULL terminated <b>/ char&nbsp; channel[11];&nbsp; /</b> Channel designation, NULL terminated <b>/ char&nbsp; dataquality;&nbsp; /</b> Data quality indicator <b>/ char&nbsp; type;&nbsp; /</b> MSTrace type code <b>/ hptime_t&nbsp; starttime;&nbsp; /</b> Time of first sample <b>/ hptime_t&nbsp; endtime;&nbsp; /</b> Time of last sample <b>/ double&nbsp; samprate;&nbsp; /</b> Nominal sample rate (Hz) <b>/ int64_t&nbsp; samplecnt;&nbsp; /</b> Number of samples in trace coverage */ void&nbsp; <b>datasamples;&nbsp; /</b> Data samples, 'numsamples' of type 'sampletype'*/ int64_t&nbsp; numsamples;&nbsp; /* Number of data samples in datasamples <b>/ char&nbsp; sampletype;&nbsp; /</b> Sample type code: a, i, f, d */ void&nbsp; <b>prvtptr;&nbsp; /</b> Private pointer for general use */ StreamState&nbsp; <b>ststate;&nbsp; /</b> Stream processing state information */ struct MSTrace_s <b>next;&nbsp; /</b> Pointer to next trace */ } MSTrace;</p><p>typedef struct MSTraceGroup_s { int32_t&nbsp; numtraces;&nbsp; /* Number of MSTraces in the trace chain */ struct MSTrace_s <b>traces;&nbsp; /</b> Root of the trace chain */ } MSTraceGroup;</p><p>Explanation of fields:</p><p>dataquality: A SEED data quality indicator, either 'D', 'R', 'Q' or 'M'.&nbsp; This value will be (binary) 0 when the quality is unknown or mixed.</p><p>network: station: location: channel: MSTrace identifiers as NULL terminated strings.</p><p>type: A single character trace type indicator.&nbsp; This field is not used by libmseed but could be used for application specific trace identification.</p><p>starttime: MSTrace start time, the time of the first sample, as a high precision epoch time (see ms_time(3)).&nbsp; This time can be converted using the various ms_hptime2&lt;X&gt; functions.</p><p>endtime: MSTrace end time, the time of the last sample, as a high precision epoch time (see ms_time(3)).&nbsp; This time can be converted using the various ms_hptime2&lt;X&gt; functions.</p><p>samprate: The sample rate in samples per second in double precision.</p><p>samplecnt: The sample count, i.e. number of data samples in the trace.</p><p>datasamples: A pointer to the data samples.&nbsp; If no data samples are included this will be 0.&nbsp; The 'numsamples' field indicates how many samples are in this array and the 'sampletype' field indicates what type of samples they are.</p><p>numsamples: The number of samples pointed to by the 'datasamples' pointer.</p><p>sampletype: The type of samples pointed to by the 'datasamples' pointer.&nbsp; Supported types are 'a' (ASCII), 'i' (integer), 'f' (float) and 'd' (double).&nbsp; The size of each sample type in bytes is returned by the get_samplesize(3) lookup routine.</p><p>prvtptr: A private pointer for general use.&nbsp; This pointer is not used by libmseed and can safely be used by the calling program.</p><p>ststate: Pointer to a StreamState struct used internally to track stream oriented state variables.&nbsp; Memory for this only allocated when needed.</p><p>next: A pointer to the next MSTrace structure.&nbsp; The value will be 0 for the last link in a chain of MSTrace structures.</p><p>-- Log Messages --</p><p>All of the log and diagnostic messages emitted by the library functions use the same interface.&nbsp; The output from this interface can be controlled.&nbsp; This is useful when the library will be embedded in a larger system with a custom logging facility.&nbsp; See the man page for more details.</p><p>ms_log() : the central logging facility.&nbsp; Behavior is controlled by the settings specified with ms_loginit().</p><p>ms_loginit() : set the functions and prefixes used for log, diagnostic and error messages.</p><p>The default destination for log messages is standard output (stdout), while all diagnostic (including error) messages go to standard error (stderr).&nbsp; Most of the internal messages emmited by the library are considered diagnostic and will, by default, go to standard error.</p><p>The default prefix for log and diagnostic messages is nothing. The default prefix for diagnostic error messages is &quot;error: &quot;.</p><p>There are reentrant versions of these functions that operate directly on a logging parameter MSLogParam struct.&nbsp; These are intended for use in threaded programs or where a complex logging scheme is desired.&nbsp; See the man pages for more details.</p><p>-- Waveform Data --</p><p>Waveform data samples are managed by libmseed in a couple of different formats depending on how they are unpacked or will be packed.&nbsp; An array of samples is completely represented by an array of sample values, the number of samples and a sample type.&nbsp; The number of samples is always the actual number of sample values, not the number of bytes needed for storing the values.&nbsp; Samples can be either ASCII, 32-bit integer, 32-bit floats or 64-bit double precision floats.</p><p>Sample types are identified by a type character: 'a' - ASCII (8 bits) 'i' - integer (32 bits) 'f' - float (32 bits) 'd' - double (64 bits)</p><p>The size of each sample type in bytes is returned by the get_samplesize(3) lookup routine.</p><p>-- Common Usage --</p><p>Example programs using libmseed are provided in the 'examples' directory of the source code distribution.</p><p>One of the most common tasks is to read a file of Mini-SEED records and either perform some action based on the header values or apply some process to the data samples.&nbsp; This task is greatly simplified by using the library functions ms_readmsr(3) and ms_readtraces(3).&nbsp; The ms_readmsr(3) routine will open a specified file and return MSRecord structures for each Mini-SEED record it reads from the file.&nbsp; The ms_readtraces(3) routine will do the same except add all the data read to a MSTraceGroup, this is ideal for quickly reading data for processing.&nbsp; Both of these routines are able to automatically detect record length.</p><p>If your application is not designed to read Mini-SEED from files the library also provides functions to detect and parse Mini-SEED records in memory buffers.&nbsp; For more information see ms_detect(3) and msr_parse(3).</p><p>Skeleton code for reading a file with ms_readmsr(3):</p><p>main() { MSRecord *msr = NULL; int retcode;</p><p>while ( (retcode = msr_readmsr (&amp;msr, filename, 0, NULL, NULL, 1, 0, verbose)) == MS_NOERROR ) { /* Do something with the record here, e.g. print */ msr_print (msr, verbose); }</p><p>if ( retcode != MS_ENDOFFILE ) ms_log (2, &quot;Cannot read %s: %s\n&quot;, filename, ms_errorstr(retcode));</p><p>/* Cleanup memory and close file */ ms_readmsr (&amp;msr, NULL, 0, NULL, NULL, 0, 0); }</p><p>For reading two files with ms_readtraces(3):</p><p>main() { MSTraceGroup *mstg = NULL; int retcode;</p><p>retcode = ms_readtraces (&amp;mstg, filename, 0, -1.0, -1.0, 0, 1, 0, verbose);</p><p>if ( retcode != MS_ENDOFFILE ) ms_log (2, &quot;Cannot read %s: %s\n&quot;, filename, ms_errorstr(retcode));</p><p>retcode = ms_readtraces (&amp;mstg, filename2, 0, -1.0, -1.0, 0, 1, 0, verbose);</p><p>if ( retcode != MS_ENDOFFILE ) ms_log (2, &quot;Cannot read %s: %s\n&quot;, filename2, ms_errorstr(retcode));</p><p>if ( ! mstg ) { fprintf (stderr, &quot;Error reading file\\n&quot;); return -1; }</p><p>/* Do something with the traces here, e.g. print */ mst_printtracelist (mstg, 0, verbose, 0);</p><p>mst_freegroup (&amp;mstg); }</p><p>Another common task is to create (pack) Mini-SEED records. The library supports packing of Mini-SEED either from MSRecord structures, MSTrace structures or MSTraceGroup collections using, respectively, msr_pack(3), mst_pack(3) or mst_packgroup(3).&nbsp; In each case the appropriate data structure and parameters are provided to the routine along with a function pointer to a routine that will be called each time a record is complete and should be disposed of.</p><p>When packing Mini-SEED records the concept of a record header template is used, the template is always in the form of a MSRecord structure.&nbsp; This allows the calling program to dictate the contents, with a few exceptions, of the header in the final data records.</p><p>Skeleton code for creating (packing) and writing Mini-SEED records to a file with mst_writemseed(3):</p><p>main() { int precords; int verbose = 0; char msfile = &quot;output.mseed&quot;; MSTrace *mst;</p><p>mst = mst_init (NULL);</p><p>/* Populate MSTrace values */ strcpy (mst-&gt;network, &quot;XX&quot;); strcpy (mst-&gt;station, &quot;TEST&quot;); strcpy (mst-&gt;channel, &quot;BHE&quot;); mst-&gt;starttime = ms_seedtimestr2hptime (&quot;2004,350,00:00:00.000000&quot;); mst-&gt;samprate = 40.0;</p><p>mst-&gt;datasamples = dataptr; /* pointer to 32-bit integer data samples <b>/ mst-&gt;numsamples = 1234; mst-&gt;sampletype = 'i';&nbsp; /</b> declare type to be 32-bit integers */</p><p>/* Write 4096 byte, big-endian records, using Steim-2 compression */ precords = mst_writemseed (mst, msfile, 1, 4096, DE_STEIM2, 1, verbose);</p><p>ms_log (0, &quot;Wrote %d records to %s\n&quot;, precords, msfile);</p><p>/* Disconnect datasamples pointer, otherwise mst_free() will free it */ mst-&gt;datasamples = NULL;</p><p>mst_free (&amp;mst); }</p></div>
</div>

</body></html>